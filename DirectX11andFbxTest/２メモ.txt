バッファオーバーフロー...処理すべきデータや処理した後のデータを保持するための
　　　　　　　　　　　　 メモリ領域（バッファ）を超えること

Visual Studioでstrcpyやscanfが使えないのはバッファーの容量が指定されていないため
オーバーフローするから


a++と++aの違い...int x,a=1;
                 x=++a;  ->結果2  aに1足した後xに代入する

                 int x,a=1;
                 x=a++;  ->結果1　xに値を代入した後aに1足す

ヘッダファイル：関数のプロトタイプや構造体、定数などがまとめられているファイル　　　　　　　　　

#include:ファイルのコピペ(展開)

#define:(例)#define MAX_HP(30)=30として固定される。変更できない。
　　　　#define MAX_HPと書けばコンパイラに登録される

#ifndef:if not define A Aであれば実行する
　　　　#ifndef～{(#ifndefが真なら実行する。
        偽ならばコンパイラは無視する(コメントアウトと同じ))
        #endif }
        (例)#ifndef A_H//A_Hは定義されていない(1回目がほぼ確定)
            #define A_H//2回目以降が実行されないように宣言
　　　　　　#endif

static変数：ローカル→そのスコープ内でしか変数の値を変更できない


& 論理積(and):両方とも真なら真
| 論理和(or);どちらかが真なら真
^ 排他的論理和(xor):両方とも偽なら真
~ |の補数：

>> シフト演算子:a>>2なら右に2ビットシフト(2進数010101→101000)



基本的にグローバルな値は0で初期化される
bool型の場合だとfalse

見やすい、読みやすいコード→ネスト({})の数を減らす

static:ローカル変数→寿命が延びる→生成されてからプログラム終了まで(グローバル変数)
　　　 グローバル変数→別のソースで使えなくなる

関数の宣言：別のCPPで使う→ヘッダに書く
　　　　　　別のCPPで使わない→CPPに書く

ローカルとグローバルのポインタ配列：ローカルだと寿命が短すぎる
　　　　　　　　　　　　　　　　グローバルはメモリの節約にならない

メモリの動的確保：開発側でメモリの確保、解放の責任を負う方法。
　　　　　　　　　メリット…自分たちで確保と解放が管理できる。
　　　　　　　　　デメリット…メモリリーク(バグ)が生じる。しかもエラーと同じところで起こっていない時がある　　　　　　　　　　　　　　　　　　　　　　

メモリの静的確保：PC側にメモリの確保と解放の責任を負ってもらう

動的確保のやり方：stdlib.hをinclude→malloc(確保)、free(解放)
                  int *p = nullptr;
                  p = malloc(確保したいサイズ、例sizeof(int)) 
                  free(消したいポインタ変数、例 p)//これを忘れたらメモリリーク

CSV=Comma Sparated Values(拡張子)
    値を「,」区切りにしてくれる
　　1,2,3,4,5

3D→モデルが必要→形式が複数ある→XFile:DirectXで読み込める
                                  FBX:FBXを読み込むSDKをさがす
                                  OBJ:自分たちで用意しないといけない



暗黙的型変換:型が違う際にプログラム側で自動的に行われる型変換
　　　　　　例）float a=2.8f
                int  b=a;

明示的な型変換：型変換をコード上でしっかりと明示する
　　　　　　　例) float a=2.8f;
                  int b=(int)a; 

　　　　　　グローバル→そのCPP内でしか値を変更できない
　　　　　　プログラムの開始から終了までメモリ領域を解放しない変数

メモリについて：・プログラム領域：関数のメモリが入っている
　　　　　　　　・静的領域：グローバル変数のメモリが入っている
　　　　　　　　・ヒープ領域
　　　　　　　　・スタック領域：ローカル内のメモリが入っている

シングルトンパターン：プログラム内で唯一のオブジェクトを使用するパターン
　　　　　　例）ゲームだとDirectXのデバイスがまとめられたライブラリクラス
　　　　　　　　　　何個も作られてはいけないオブジェクトを一つにする

staricメソッド→クラスに属する
通常メソッド→インスタンス(オブジェクト)に属する

staticメソッドの制約：通常のメンバは使えない
→staticメソッドはクラスに属しているのでインスタンス化された場合に使用できるメンバは使えない

クラスの継承とメンバの区別の仕方：AはBである(継承)例(ホイミスライムはスライムである)
　　　　　　　　　　　　　　　　　AはBを持っている(メンバとして持つ)例(ホイミスライムはホイミを持っている)→スライムに持たせてはいけない

object→オブジェクトの基底
↓
SpriteObject→スプライト（2Dテクスチャ）描画機能追加


cmp(コマンドプロンプト)使い方
→cd c:\
→cd cpro
→cl ソースファイル名
→exe名

アリゴリズム　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　
スタック(LIFO)：Last Input FirstOut。 後入れ先出しが保証されたデータ構造
データの取得は最後に追加したデータが取得できるようになっている。
この時にデータを追加することを「Push」(インキュー)、取得することを「Pop」(デキュー)といいます。
?
キュー(FIFO)：First Input FirstOut。先入れ先出し。
データの取得は最初に追加したデータが取得できるようになっている。
この時にデータを追加することを「Push」(インキュー)、取得することを「Pop」(デキュー)といいます。

リスト：データのつながりを持たせるデータ構造

配列：連続したデータのつながりを保証したデータ構造

グラフ：頂点(ノード)と辺(エッジ)でデータのつながり表すデータ構造
種類→有効グラフ：辺に向きがある。辺の矢印が向いている方向にアクセスできる
　　　無効グラフ：有効グラフの逆。辺でつながっている頂点同氏はお互いを知っている

重み：頂点間のコスト(距離、時間、量)
例)A→B→Cまでコストが7かかるとして、A→Cまで直接行くと5しかからない。

隣接：頂点と頂点が直接つながっていること(頂点間に辺がある)

パス：任意の頂点から頂点へ行くための頂点の列

閉路：始点と終点が同じ位置のパス
例)A→B→C→A みたいにA始点、A終点

連結グラフ(連結)：任意の頂点間にパスがつながっているグラフ(すべてつながっている）
非連結グラフ：例)A→B→CとD→Eみたいに個別になっていること

次数：１つの頂点から出ている辺の数

木：閉路がない連結グラフ

隣接行列：グラフを表現するのに行列を使う
　　　　　行列は頂点*頂点の正方行列になっている
例) 基点/先  A 	   B 	 C    D 
　  A 	　   0 	   1 	 1    1 
　  B 	　   1 	   0 	 0    1 
　  C 	　   1 	   0 	 0    0 
　  D 	　   1 	   1 	 0    0 
これに重みを加えると、配列の数字を変える

隣接リスト：各頂点に隣接する頂点のリストを持っていてそれ以上に状況を表現する。
例) 基点の頂点 	 繋がってる頂点 
 　　　A 	 　　　B C D 
　　　 B 	 　　　A D 
 　　　C 	　　　 A 
 　　　D 	 　　　A B 

BFS→幅優先探索→始点と終点を決める(今回のサンプルは始点0終点0)
　　　　　　　　 隣接している頂点を優先して調べる
　　　　　　　　 すべて違った場合調べた頂点と隣接してる頂点と隣接を調べる
sampleから
↓
std::vecter<(型)>→型はコンテナ(vecter)に入れる型
vecter：動的配列→必要に応じて要素数の追加や削除ができる

<Node*>①宣言時の要素数は0
　　　 ②push_backで引数の値を要素に追加する

範囲for:for(型 変数名:配列 or コンテナ)
注意点→参照等を付けないとコピーになる
　　int list[3]={1,2,3}:
　　for(int val:list)
　　{
  　　 val += 10;
　　}
　　printf("%d\n",list[0]);
　　↓
　　11が表示

木構造：閉路のに連結で木の形をしていることが多いことから木構造または木と呼ばれている

ルート：木構造の始まりの部分

ノード：リーの枝分かれ部分のこと

ブランチ：ノードとノードの接続のこと

親子関係：ノードの上下関係(親が上、子が下)

兄弟ノード：同じ親を持つノード

葉：木構造の末端の部分

必要な処理→・追加、削除、検索

追加：ノードに新しいノードを追加する　
①指定した葉に追加する。
②葉に別の木構造を追加。また、途中のノードに挿入する

削除：ノードを削除する→・そのノードだけ消す
　　　　　　　　　　　　・そのノード以下すべて消す(こっちのほうがいい)

検索：指定したノードが木構造の中にあるか調べる


ベルマンフォード法：2点間の頂点の最短距離を求める
　　　　　　　　　　基点の最短距離＋次の頂点までのコスト＜次の頂点の最短距離(初めは∞として考える)
        　　　　　　最大計算量＝頂点の数*辺の数
　　　　　　　　　　負の閉路の見つけ方→計算量を調べて最大量を超えたら閉路ありと考える(無限ループ)



ダイクストラ法：２点間の最短経路を求めるアルゴリズムで、頂点を主体として経路を割り出します。
　　　　　　　　ベルマンフォードと比べ負のコストを扱わず経路の検出が早い
　　　　　　　　そしてベルマンフォードは辺を主体とし、ダイクストラは頂点を主体とする
　　　　　　　　①始点と終点を決める
　　　　　　　　②経路距離の初期化　始点:0 その他:∞
　　　　　　　　③始点と隣接している頂点までの距離を測る
　　　　　　　　　　　　　　　　　＋
　　　　　　　　辺のコスト　<　隣接先の頂点のコスト
　　　　　　　　調査が完了したら候補から外す。もし更新が行われたらその頂点と隣接してる頂点を候補に追加する
　　　　　　　　④次の候補の距離を測る→最も値が小さい頂点を選ぶ
　　　　　　　　⑤④を候補がなくなるまで繰り返す

欠点→目先の頂点のコストしか見ない→低いコストへ→ゴールに行くわけではない

ヒューリスティックコスト(推定コスト)：ゴールに近いか遠いかを判断するための付加情報→ゴールまでの距離に使う

ユークリッド距離：ゴールと頂点の２点間の距離を算出してヒューリスティックコストとして使う
　　
マンハッタン：スタートからゴールまでの各軸の距離を求めて算出した合計計値をヒューリスティックコストとして使う
　　　　　
オープンリスト→探索予定頂点リスト
クローズリスト→探索済み頂点リスト
①2D→オープン
②オープン→2D　　　　　
③2Dの隣接頂点を調べる
④各頂点でトータルコストを出す　
⑤頂点をオープンに入れる
⑥2D→クローズ

流れ
①開始頂点と終点頂点を決める
②開始頂点をオープンリストに入れる
③スタート位置の隣接頂点を調べる
③.5オープンリストから③の頂点を削除
④頂点をオープンに入れる
⑤③の頂点の隣接頂点を調べる
⑥各頂点でヒューリスティックコストを算出する
⑦各頂点をオープンリストに入れる
　(条件　・追加対象の頂点がオープン、クローズのリストに無い
　　　　 ・オープンリストにあるかつオープン側のコストよりも新規のコストが低い＋古いほうの情報は削除または古い情報を更新
　　　　 ・クローズリストにあるかつクローズ側のコストよりも新規のコストが低い＋クローズの情報は消す)
⑧オープンリストのソート(トータルリストで昇順)
⑨③～⑧をオープンリストがなくなるか、③の頂点がゴールまで繰り返す

関数型：関数を使って仕様を完成させるプログラム方式の一つ(プログラミングパラダイム)　
　　　　引数の結果から出力結果を出す(その特性を満たしていない関数は手続き)

プログラミングパラダイム：プログラマのプログラムに対する
		見方、アプローチ方法のことで、どのパラダイムを使用するかで
		設計、処理内容が異なる
　　　　　　　

命令型(手続き型)：問題を解決するために必要な命令を適切に並べていくプログラミング方法

オブジェクト指向型：プログラミングは問題の性質をオブジェクト単位で分けるプログラミング方法

独立性：関数は入力(引数)の情報のみにより出力が決まる→使い勝手が良い

副作用：状態を参照し、状態に変化を加えることで、次回の処理にまで影響を与える
　　　　→変数の代入→値を書き換える→関数では結果が変わるかもしれない→手続き
　　　　服採用のあるコード：バグが発生する可能性がある
　　　　副作用が発生する代入→破壊的代入
　　　　副作用が発生しない代入→束縛


関数型とオブジェクト指向型は全くの対局

参照透過性：同じ式は何度やっても同じ結果になる性質→関数型の関数は参照透過性であるべき
　　　　　　
並列：CPUやGPUのコアを複数同時に動かすこと。または同時に複数の処理を実行する
　　　関数型の関数は並列に有利








